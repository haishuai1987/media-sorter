# 错误处理说明 (v1.7.0)

## 概述

v1.7.0 引入了统一的错误处理框架，提供：
- 🔄 自动重试机制
- 🛡️ 错误分类和恢复
- 💬 用户友好的错误消息
- 📊 错误统计和监控

## 核心功能

### 1. 错误分类

系统自动将错误分为以下类型：
- **网络错误** - 超时、连接失败等
- **API错误** - 401、403、429、500等
- **文件错误** - 文件不存在、权限不足等
- **权限错误** - 访问被拒绝
- **验证错误** - 输入格式不正确
- **超时错误** - 操作超时

### 2. 自动重试

对于可恢复的错误（如网络超时），系统会自动重试：

```python
from error_handler import retry_on_error

@retry_on_error(max_retries=3, delay=1.0, backoff=2.0)
def network_request():
    # 你的网络请求代码
    pass
```

**特性：**
- 最多重试3次
- 指数退避（1秒 → 2秒 → 4秒）
- 智能判断是否应该重试

### 3. 安全执行

捕获所有异常，避免程序崩溃：

```python
from error_handler import safe_execute

success, result, error = safe_execute(
    lambda: risky_operation(),
    default_value=None,
    operation='风险操作'
)

if not success:
    print(f"操作失败: {error}")
```

### 4. 错误恢复

提供预定义的恢复策略：

```python
from error_handler import ErrorRecovery

# 网络错误恢复（自动重试）
success, result = ErrorRecovery.recover_from_network_error(
    network_function,
    arg1,
    arg2
)

# 文件错误恢复（捕获常见文件错误）
success, result = ErrorRecovery.recover_from_file_error(
    file_function,
    filepath
)
```

## 友好错误消息

系统会将技术错误转换为用户友好的消息：

| 原始错误 | 友好消息 |
|---------|---------|
| `Connection timeout` | 网络连接超时，请检查网络后重试 |
| `HTTP 401` | Cookie已过期或无效，请重新登录 |
| `HTTP 429` | 请求过于频繁，请稍后再试 |
| `Permission denied` | 没有权限访问文件或目录 |
| `File not found` | 文件不存在 |

## 使用场景

### 场景1: TMDB API调用

```python
@retry_on_error(max_retries=3, delay=1.0)
def search_movie(title):
    # TMDB搜索
    # 网络错误会自动重试
    pass
```

### 场景2: 115网盘批量操作

```python
def batch_rename(files):
    success_count = 0
    failed = []
    
    for file_id, new_name in files.items():
        try:
            rename_file(file_id, new_name)
            success_count += 1
        except Exception as e:
            # 记录错误但继续处理
            error_msg = ErrorHandler.get_friendly_message(e)
            failed.append((file_id, error_msg))
    
    return success_count, failed
```

### 场景3: 文件扫描

```python
def scan_directory(path):
    success, files, error = safe_execute(
        lambda: os.listdir(path),
        default_value=[],
        operation=f'扫描目录 {path}'
    )
    
    if not success:
        print(f"扫描失败: {error}")
        return []
    
    return files
```

## 错误统计

查看错误统计信息：

```python
# API错误统计
stats = api_client.get_error_stats()
print(f"错误次数: {stats['error_count']}")
print(f"最后错误: {stats['last_error']}")

# 性能统计
perf = api_client.get_performance_stats()
print(f"请求次数: {perf['request_count']}")
print(f"错误率: {perf['error_rate']:.2%}")
```

## 配置选项

在配置文件中启用详细日志：

```json
{
  "debug_mode": true,
  "error_log_level": "verbose"
}
```

## 最佳实践

1. **网络操作** - 使用 `@retry_on_error` 装饰器
2. **批量操作** - 捕获单个错误，继续处理其他项
3. **文件操作** - 使用 `safe_execute` 或 `ErrorRecovery`
4. **用户提示** - 使用 `get_friendly_message` 获取友好消息
5. **错误日志** - 使用 `log_error` 记录详细信息

## 性能影响

- 错误处理开销：< 1ms
- 重试延迟：可配置（默认1秒起）
- 内存占用：极小（< 1MB）

## 兼容性

- ✅ 完全向后兼容
- ✅ 不影响现有功能
- ✅ 可选启用

## 示例代码

完整示例请参考：
- `error_handler.py` - 核心模块
- `test_error_handler.py` - 测试用例
- `error_handler_integration.py` - 集成示例

## 常见问题

**Q: 如何禁用自动重试？**  
A: 设置 `max_retries=0`

**Q: 如何自定义错误消息？**  
A: 修改 `ErrorHandler.ERROR_MESSAGES` 字典

**Q: 如何添加新的错误类型？**  
A: 在 `ErrorType` 枚举中添加新类型

**Q: 重试会影响性能吗？**  
A: 只有在错误发生时才会重试，正常情况下无影响

## 更新日志

详见 `CHANGELOG-v1.7.0.md`
