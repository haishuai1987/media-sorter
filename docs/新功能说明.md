# 新功能说明 (v2.1.0)

## 🎉 新增功能

v2.1.0 引入了三个强大的新功能，提升了系统的识别准确度、灵活性和可扩展性。

---

## 1️⃣ 高级识别器

### 概述

融合了 NAS-Tools 和 MoviePilot 的最佳识别算法，提供更准确、更全面的媒体文件识别。

### 特性

- ✨ **更全面的正则模式** - 支持更多格式和命名风格
- ✨ **智能标题提取** - 自动移除识别到的信息，提取纯净标题
- ✨ **质量评分系统** - 用于智能去重和版本比较
- ✨ **HDR 识别** - 支持 HDR10+、Dolby Vision 等
- ✨ **音频编码识别** - 支持 Atmos、TrueHD、DTS-HD 等

### 使用方法

```python
from core.advanced_recognizer import get_advanced_recognizer

# 获取识别器实例
recognizer = get_advanced_recognizer()

# 识别文件
filename = "The.Matrix.1999.1080p.BluRay.x264.DTS-RARBG.mkv"
result = recognizer.recognize(filename)

print(f"标题: {result['title']}")
print(f"年份: {result['year']}")
print(f"分辨率: {result['resolution']}")
print(f"视频编码: {result['video_codec']}")
print(f"音频编码: {result['audio_codec']}")
print(f"来源: {result['source']}")

# 计算质量分数
score = recognizer.get_quality_score(result)
print(f"质量分数: {score}")
```

### 识别结果

```python
{
    'original_name': '原始文件名',
    'title': '标题',
    'year': 2023,
    'season': 1,           # 电视剧季数
    'episode': 1,          # 电视剧集数
    'resolution': '1080p',
    'video_codec': 'H264',
    'audio_codec': 'AAC',
    'source': 'BluRay',
    'hdr': 'HDR10+',
    'language': ['chs', 'eng'],
    'subtitle': ['简体', '中英'],
    'release_group': 'RARBG',
    'is_tv': False,
}
```

### 支持的格式

#### 分辨率
- 8K, 4K, UHD, FHD, HD
- 2160p, 1080p, 720p, 480p, 360p

#### 视频编码
- H.264, H264, x264, AVC
- H.265, H265, HEVC, x265
- AV1, VP9, MPEG-2

#### 音频编码
- AAC, AC3, AC-3
- DTS, DTS-HD
- TrueHD, Atmos
- FLAC, DDP, DD+

#### 来源
- BluRay, Blu-Ray, BDMV, BD
- WEB-DL, WEBDL, WEBRip
- HDTV, DVDRip, HDRip
- REMUX, BRRip

#### HDR
- HDR10, HDR10+
- Dolby Vision, DV
- HLG, SDR

---

## 2️⃣ 模板引擎

### 概述

灵活的文件命名模板系统，支持多种预设风格和自定义模板。

### 特性

- ✨ **多种预设模板** - 默认、简单、详细、NAS-Tools、MoviePilot、Plex、Jellyfin 风格
- ✨ **自定义模板** - 用户可以创建自己的命名模板
- ✨ **格式化支持** - 支持数字格式化（如 `{season:02d}` → `01`）
- ✨ **模板验证** - 自动验证模板语法
- ✨ **智能清理** - 自动移除空括号和多余空格

### 使用方法

```python
from core.template_engine import get_template_engine

# 获取模板引擎实例
engine = get_template_engine()

# 准备上下文数据
context = {
    'title': '流浪地球',
    'year': 2019,
    'resolution': '1080p',
    'video_codec': 'H264',
    'audio_codec': 'AAC',
    'source': 'BluRay',
    'ext': 'mkv',
}

# 使用预设模板
result = engine.render('movie_default', context)
print(result)
# 输出: 流浪地球 (2019)/流浪地球 (2019) [1080p-BluRay].mkv

# 添加自定义模板
engine.add_template('my_style', '{title} [{year}] - {quality}.{ext}')
result = engine.render('my_style', context)
print(result)
# 输出: 流浪地球 [2019] - 1080p-BluRay.mkv
```

### 预设模板

#### 电影模板

| 模板名 | 格式 | 示例 |
|--------|------|------|
| `movie_default` | `{title} ({year})/{title} ({year}) [{resolution}-{source}].{ext}` | 流浪地球 (2019)/流浪地球 (2019) [1080p-BluRay].mkv |
| `movie_simple` | `{title} ({year})/{title} ({year}).{ext}` | 流浪地球 (2019)/流浪地球 (2019).mkv |
| `movie_detailed` | `{title} ({year})/{title} ({year}) [{resolution} {video_codec} {audio_codec} {source}].{ext}` | 流浪地球 (2019)/流浪地球 (2019) [1080p H264 AAC BluRay].mkv |
| `nas_movie` | NAS-Tools 风格 | 流浪地球 (2019)/流浪地球 (2019) [1080p H264 AAC].mkv |
| `plex_movie` | Plex 风格 | 流浪地球 (2019)/流浪地球 (2019).mkv |

#### 电视剧模板

| 模板名 | 格式 | 示例 |
|--------|------|------|
| `tv_default` | `{title}/Season {season:02d}/{title} - S{season:02d}E{episode:02d} [{resolution}-{source}].{ext}` | 权力的游戏/Season 01/权力的游戏 - S01E01 [1080p-WEB-DL].mkv |
| `tv_simple` | `{title}/S{season:02d}/{title} - S{season:02d}E{episode:02d}.{ext}` | 权力的游戏/S01/权力的游戏 - S01E01.mkv |
| `tv_detailed` | 详细信息 | 权力的游戏/Season 01/权力的游戏 - S01E01 [1080p H265 DTS WEB-DL].mkv |
| `nas_tv` | NAS-Tools 风格 | 权力的游戏/Season 01/权力的游戏 S01E01 [1080p H265 DTS].mkv |
| `plex_tv` | Plex 风格 | 权力的游戏/Season 01/权力的游戏 - s01e01.mkv |

### 可用占位符

| 占位符 | 说明 | 示例 |
|--------|------|------|
| `{title}` | 标题 | 流浪地球 |
| `{year}` | 年份 | 2019 |
| `{season}` | 季数 | 1 |
| `{season:02d}` | 季数（两位数） | 01 |
| `{episode}` | 集数 | 1 |
| `{episode:02d}` | 集数（两位数） | 01 |
| `{resolution}` | 分辨率 | 1080p |
| `{video_codec}` | 视频编码 | H264 |
| `{audio_codec}` | 音频编码 | AAC |
| `{source}` | 来源 | BluRay |
| `{quality}` | 质量（自动生成） | 1080p-BluRay |
| `{hdr}` | HDR 类型 | HDR10+ |
| `{ext}` | 扩展名 | mkv |

### 模板验证

```python
# 验证模板
is_valid, error = engine.validate_template('{title} ({year}).{ext}')
if is_valid:
    print("模板有效")
else:
    print(f"模板无效: {error}")
```

---

## 3️⃣ 事件系统

### 概述

简单而强大的事件驱动架构，支持模块解耦和插件扩展。

### 特性

- ✨ **发布/订阅模式** - 松耦合的事件通信
- ✨ **优先级支持** - 控制处理器执行顺序
- ✨ **一次性处理器** - 只触发一次的事件处理
- ✨ **事件历史** - 记录最近的事件
- ✨ **统计信息** - 事件数量和类型统计
- ✨ **装饰器支持** - 优雅的事件处理器定义

### 使用方法

#### 基本用法

```python
from core.events import get_event_bus

# 获取事件总线实例
bus = get_event_bus()

# 定义处理器
def on_file_processed(event):
    print(f"文件已处理: {event.data['filename']}")

# 订阅事件
bus.on('file.processed', on_file_processed)

# 发布事件
bus.emit('file.processed', {'filename': 'test.mkv'})
```

#### 使用装饰器

```python
from core.events import event_handler

@event_handler('file.processed', priority=10)
def on_file_processed(event):
    print(f"文件已处理: {event.data['filename']}")

# 发布事件
from core.events import emit
emit('file.processed', {'filename': 'test.mkv'})
```

#### 一次性处理器

```python
# 只触发一次
bus.once('app.ready', lambda event: print("应用已就绪"))

bus.emit('app.ready')  # 触发
bus.emit('app.ready')  # 不触发
```

#### 优先级

```python
# 高优先级先执行
bus.on('event', high_priority_handler, priority=10)
bus.on('event', low_priority_handler, priority=1)
```

### 预定义事件类型

```python
from core.events import EventTypes

# 文件处理事件
EventTypes.FILE_SCAN_START
EventTypes.FILE_SCAN_COMPLETE
EventTypes.FILE_PROCESS_START
EventTypes.FILE_PROCESS_COMPLETE
EventTypes.FILE_RENAME_START
EventTypes.FILE_RENAME_COMPLETE
EventTypes.FILE_MOVE_START
EventTypes.FILE_MOVE_COMPLETE

# 元数据事件
EventTypes.METADATA_QUERY_START
EventTypes.METADATA_QUERY_COMPLETE

# 去重事件
EventTypes.DEDUPE_START
EventTypes.DEDUPE_COMPLETE
EventTypes.DEDUPE_FOUND

# 冲突事件
EventTypes.CONFLICT_DETECTED
EventTypes.CONFLICT_RESOLVED

# 清理事件
EventTypes.CLEANUP_START
EventTypes.CLEANUP_COMPLETE

# 进度事件
EventTypes.PROGRESS_UPDATE

# 系统事件
EventTypes.SYSTEM_START
EventTypes.SYSTEM_STOP
EventTypes.SYSTEM_ERROR
```

### 事件对象

```python
class Event:
    type: str          # 事件类型
    data: Any          # 事件数据
    source: str        # 事件来源
    timestamp: float   # 时间戳
    datetime: datetime # 日期时间
```

### 统计和历史

```python
# 获取统计信息
stats = bus.get_stats()
print(f"总事件数: {stats['total_events']}")
print(f"按类型统计: {stats['events_by_type']}")

# 获取事件历史
history = bus.get_history(limit=10)
for event in history:
    print(f"{event.type} @ {event.datetime}")
```

---

## 🔗 集成示例

### 完整的文件处理流程

```python
from core.advanced_recognizer import get_advanced_recognizer
from core.template_engine import get_template_engine
from core.events import get_event_bus, EventTypes

# 初始化
recognizer = get_advanced_recognizer()
engine = get_template_engine()
bus = get_event_bus()

# 设置事件监听
@event_handler(EventTypes.FILE_PROCESS_START)
def on_start(event):
    print(f"开始处理: {event.data['filename']}")

@event_handler(EventTypes.FILE_PROCESS_COMPLETE)
def on_complete(event):
    print(f"处理完成: {event.data['new_name']}")

# 处理文件
def process_file(filename):
    # 1. 发布开始事件
    bus.emit(EventTypes.FILE_PROCESS_START, {'filename': filename})
    
    # 2. 识别文件
    info = recognizer.recognize(filename)
    
    # 3. 生成新文件名
    context = {
        'title': info['title'],
        'year': info['year'],
        'season': info['season'],
        'episode': info['episode'],
        'resolution': info['resolution'],
        'video_codec': info['video_codec'],
        'audio_codec': info['audio_codec'],
        'source': info['source'],
        'ext': 'mkv',
    }
    
    template = 'tv_default' if info['is_tv'] else 'movie_default'
    new_name = engine.render(template, context)
    
    # 4. 发布完成事件
    bus.emit(EventTypes.FILE_PROCESS_COMPLETE, {
        'filename': filename,
        'new_name': new_name,
        'quality_score': recognizer.get_quality_score(info)
    })
    
    return new_name

# 使用
new_name = process_file("The.Matrix.1999.1080p.BluRay.x264.DTS.mkv")
print(f"新文件名: {new_name}")
```

---

## 📝 测试

运行测试脚本验证所有功能：

```bash
python test_new_features.py
```

---

## 🎯 下一步

这些新功能为未来的扩展奠定了基础：

- **v2.2.0**: 基于模板的批量重命名
- **v2.3.0**: 插件系统增强（使用事件系统）
- **v3.0.0**: 可选的高级功能（Redis缓存、异步任务）

---

## 💡 最佳实践

1. **使用高级识别器** - 获得更准确的识别结果
2. **自定义模板** - 根据个人喜好创建命名模板
3. **监听事件** - 实现自定义的处理逻辑
4. **组合使用** - 三个功能配合使用效果最佳

---

**享受新功能带来的强大能力！** 🚀
